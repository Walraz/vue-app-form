import { ref as O, toRaw as be, computed as m, markRaw as ye, defineComponent as ke, getCurrentInstance as Q, h as y, onBeforeUnmount as _e, Transition as Be, withDirectives as Re, provide as Le, onDeactivated as Te, onActivated as Oe, onMounted as Ae, nextTick as je, watch as Fe, openBlock as T, createBlock as W, unref as Me, withCtx as I, resolveDynamicComponent as ee, createElementVNode as te, createElementBlock as N, Fragment as ne, renderList as re, normalizeClass as Y, renderSlot as oe, mergeProps as X, toHandlers as Ve, createVNode as ae, createTextVNode as ue } from "vue";
import ze from "lodash.set";
import De from "lodash.get";
const Ke = (e) => {
  const t = O(0), o = O(e), n = O({}), u = window.structuredClone(be(e)), f = m(() => Object.values(n.value)), i = (h) => {
    o.value = { ...h }, t.value++;
  };
  return {
    remountForm: t,
    formData: o,
    fieldError: n,
    fieldErrorTexts: f,
    resetDefaultForm: () => i(u),
    validateForm: (h) => {
      n.value = {};
      const d = h.safeParse(o.value);
      return d.success ? (i(d.data), !0) : (n.value = Object.entries(
        d.error.formErrors.fieldErrors
      ).reduce((p, [s, r]) => (r != null && r.length && (p[s] = r[0]), p), {}), !1);
    },
    setFormData: i
  };
}, J = {
  xs: 18,
  sm: 24,
  md: 32,
  lg: 38,
  xl: 46
}, qe = {
  size: String
};
function Ee(e, t = J) {
  return m(() => e.size !== void 0 ? { fontSize: e.size in t ? `${t[e.size]}px` : e.size } : null);
}
const H = (e) => ye(ke(e)), Ie = (e) => ye(e);
function xe(e, t) {
  return e !== void 0 && e() || t;
}
function z(e, t) {
  return e !== void 0 ? t.concat(e()) : t;
}
const se = "0 0 24 24", ie = (e) => e, G = (e) => `ionicons ${e}`, Se = {
  "mdi-": (e) => `mdi ${e}`,
  "icon-": ie,
  // fontawesome equiv
  "bt-": (e) => `bt ${e}`,
  "eva-": (e) => `eva ${e}`,
  "ion-md": G,
  "ion-ios": G,
  "ion-logo": G,
  "iconfont ": ie,
  "ti-": (e) => `themify-icon ${e}`,
  "bi-": (e) => `bootstrap-icons ${e}`
}, we = {
  o_: "-outlined",
  r_: "-round",
  s_: "-sharp"
}, Ce = {
  sym_o_: "-outlined",
  sym_r_: "-rounded",
  sym_s_: "-sharp"
}, Ne = new RegExp("^(" + Object.keys(Se).join("|") + ")"), Qe = new RegExp("^(" + Object.keys(we).join("|") + ")"), le = new RegExp("^(" + Object.keys(Ce).join("|") + ")"), He = /^[Mm]\s?[-+]?\.?\d/, Ue = /^img:/, We = /^svguse:/, Xe = /^ion-/, Ge = /^(fa-(sharp|solid|regular|light|brands|duotone|thin)|[lf]a[srlbdk]?) /, ce = H({
  name: "QIcon",
  props: {
    ...qe,
    tag: {
      type: String,
      default: "i"
    },
    name: String,
    color: String,
    left: Boolean,
    right: Boolean
  },
  setup(e, { slots: t }) {
    const { proxy: { $q: o } } = Q(), n = Ee(e), u = m(
      () => "q-icon" + (e.left === !0 ? " on-left" : "") + (e.right === !0 ? " on-right" : "") + (e.color !== void 0 ? ` text-${e.color}` : "")
    ), f = m(() => {
      let i, a = e.name;
      if (a === "none" || !a)
        return { none: !0 };
      if (o.iconMapFn !== null) {
        const d = o.iconMapFn(a);
        if (d !== void 0)
          if (d.icon !== void 0) {
            if (a = d.icon, a === "none" || !a)
              return { none: !0 };
          } else
            return {
              cls: d.cls,
              content: d.content !== void 0 ? d.content : " "
            };
      }
      if (He.test(a) === !0) {
        const [d, p = se] = a.split("|");
        return {
          svg: !0,
          viewBox: p,
          nodes: d.split("&&").map((s) => {
            const [r, v, k] = s.split("@@");
            return y("path", { style: v, d: r, transform: k });
          })
        };
      }
      if (Ue.test(a) === !0)
        return {
          img: !0,
          src: a.substring(4)
        };
      if (We.test(a) === !0) {
        const [d, p = se] = a.split("|");
        return {
          svguse: !0,
          src: d.substring(7),
          viewBox: p
        };
      }
      let x = " ";
      const h = a.match(Ne);
      if (h !== null)
        i = Se[h[1]](a);
      else if (Ge.test(a) === !0)
        i = a;
      else if (Xe.test(a) === !0)
        i = `ionicons ion-${o.platform.is.ios === !0 ? "ios" : "md"}${a.substring(3)}`;
      else if (le.test(a) === !0) {
        i = "notranslate material-symbols";
        const d = a.match(le);
        d !== null && (a = a.substring(6), i += Ce[d[1]]), x = a;
      } else {
        i = "notranslate material-icons";
        const d = a.match(Qe);
        d !== null && (a = a.substring(2), i += we[d[1]]), x = a;
      }
      return {
        cls: i,
        content: x
      };
    });
    return () => {
      const i = {
        class: u.value,
        style: n.value,
        "aria-hidden": "true",
        role: "presentation"
      };
      return f.value.none === !0 ? y(e.tag, i, xe(t.default)) : f.value.img === !0 ? y("span", i, z(t.default, [
        y("img", { src: f.value.src })
      ])) : f.value.svg === !0 ? y("span", i, z(t.default, [
        y("svg", {
          viewBox: f.value.viewBox || "0 0 24 24"
        }, f.value.nodes)
      ])) : f.value.svguse === !0 ? y("span", i, z(t.default, [
        y("svg", {
          viewBox: f.value.viewBox
        }, [
          y("use", { "xlink:href": f.value.src })
        ])
      ])) : (f.value.cls !== void 0 && (i.class += " " + f.value.cls), y(e.tag, i, z(t.default, [
        f.value.content
      ])));
    };
  }
}), Ye = {
  size: {
    type: [Number, String],
    default: "1em"
  },
  color: String
};
function Je(e) {
  return {
    cSize: m(() => e.size in J ? `${J[e.size]}px` : e.size),
    classes: m(
      () => "q-spinner" + (e.color ? ` text-${e.color}` : "")
    )
  };
}
const Ze = H({
  name: "QSpinner",
  props: {
    ...Ye,
    thickness: {
      type: Number,
      default: 5
    }
  },
  setup(e) {
    const { cSize: t, classes: o } = Je(e);
    return () => y("svg", {
      class: o.value + " q-spinner-mat",
      width: t.value,
      height: t.value,
      viewBox: "25 25 50 50"
    }, [
      y("circle", {
        class: "path",
        cx: "50",
        cy: "50",
        r: "20",
        fill: "none",
        stroke: "currentColor",
        "stroke-width": e.thickness,
        "stroke-miterlimit": "10"
      })
    ]);
  }
});
function et(e, t) {
  const o = e.style;
  for (const n in t)
    o[n] = t[n];
}
const U = {
  hasPassive: !1,
  passiveCapture: !0,
  notPassiveCapture: !0
};
try {
  const e = Object.defineProperty({}, "passive", {
    get() {
      Object.assign(U, {
        hasPassive: !0,
        passive: { passive: !0 },
        notPassive: { passive: !1 },
        passiveCapture: { passive: !0, capture: !0 },
        notPassiveCapture: { passive: !1, capture: !0 }
      });
    }
  });
  window.addEventListener("qtest", null, e), window.removeEventListener("qtest", null, e);
} catch {
}
function tt(e) {
  return e.touches && e.touches[0] ? e = e.touches[0] : e.changedTouches && e.changedTouches[0] ? e = e.changedTouches[0] : e.targetTouches && e.targetTouches[0] && (e = e.targetTouches[0]), {
    top: e.clientY,
    left: e.clientX
  };
}
function $e(e) {
  e.stopPropagation();
}
function nt(e) {
  e.cancelable !== !1 && e.preventDefault();
}
function R(e) {
  e.cancelable !== !1 && e.preventDefault(), e.stopPropagation();
}
function rt(e, t, o) {
  const n = `__q_${t}_evt`;
  e[n] = e[n] !== void 0 ? e[n].concat(o) : o, o.forEach((u) => {
    u[0].addEventListener(u[1], e[u[2]], U[u[3]]);
  });
}
function ot(e, t) {
  const o = `__q_${t}_evt`;
  e[o] !== void 0 && (e[o].forEach((n) => {
    n[0].removeEventListener(n[1], e[n[2]], U[n[3]]);
  }), e[o] = void 0);
}
function at(e) {
  return e !== Object(e) || e.isComposing === !0 || e.qKeyEvent === !0;
}
function Z(e, t) {
  return at(e) === !0 ? !1 : [].concat(t).includes(e.keyCode);
}
function ut(e, t = 250) {
  let o = !1, n;
  return function() {
    return o === !1 && (o = !0, setTimeout(() => {
      o = !1;
    }, t), n = e.apply(this, arguments)), n;
  };
}
function de(e, t, o, n) {
  o.modifiers.stop === !0 && $e(e);
  const u = o.modifiers.color;
  let f = o.modifiers.center;
  f = f === !0 || n === !0;
  const i = document.createElement("span"), a = document.createElement("span"), x = tt(e), { left: h, top: d, width: p, height: s } = t.getBoundingClientRect(), r = Math.sqrt(p * p + s * s), v = r / 2, k = `${(p - r) / 2}px`, c = f ? k : `${x.left - h - v}px`, q = `${(s - r) / 2}px`, L = f ? q : `${x.top - d - v}px`;
  a.className = "q-ripple__inner", et(a, {
    height: `${r}px`,
    width: `${r}px`,
    transform: `translate3d(${c},${L},0) scale3d(.2,.2,1)`,
    opacity: 0
  }), i.className = `q-ripple${u ? " text-" + u : ""}`, i.setAttribute("dir", "ltr"), i.appendChild(a), t.appendChild(i);
  const b = () => {
    i.remove(), clearTimeout(S);
  };
  o.abort.push(b);
  let S = setTimeout(() => {
    a.classList.add("q-ripple__inner--enter"), a.style.transform = `translate3d(${k},${q},0) scale3d(1,1,1)`, a.style.opacity = 0.2, S = setTimeout(() => {
      a.classList.remove("q-ripple__inner--enter"), a.classList.add("q-ripple__inner--leave"), a.style.opacity = 0, S = setTimeout(() => {
        i.remove(), o.abort.splice(o.abort.indexOf(b), 1);
      }, 275);
    }, 250);
  }, 50);
}
function fe(e, { modifiers: t, value: o, arg: n }) {
  const u = Object.assign({}, e.cfg.ripple, t, o);
  e.modifiers = {
    early: u.early === !0,
    stop: u.stop === !0,
    center: u.center === !0,
    color: u.color || n,
    keyCodes: [].concat(u.keyCodes || 13)
  };
}
const st = Ie(
  {
    name: "ripple",
    beforeMount(e, t) {
      const o = t.instance.$.appContext.config.globalProperties.$q.config || {};
      if (o.ripple === !1)
        return;
      const n = {
        cfg: o,
        enabled: t.value !== !1,
        modifiers: {},
        abort: [],
        start(u) {
          n.enabled === !0 && u.qSkipRipple !== !0 && u.type === (n.modifiers.early === !0 ? "pointerdown" : "click") && de(u, e, n, u.qKeyEvent === !0);
        },
        keystart: ut((u) => {
          n.enabled === !0 && u.qSkipRipple !== !0 && Z(u, n.modifiers.keyCodes) === !0 && u.type === `key${n.modifiers.early === !0 ? "down" : "up"}` && de(u, e, n, !0);
        }, 300)
      };
      fe(n, t), e.__qripple = n, rt(n, "main", [
        [e, "pointerdown", "start", "passive"],
        [e, "click", "start", "passive"],
        [e, "keydown", "keystart", "passive"],
        [e, "keyup", "keystart", "passive"]
      ]);
    },
    updated(e, t) {
      if (t.oldValue !== t.value) {
        const o = e.__qripple;
        o !== void 0 && (o.enabled = t.value !== !1, o.enabled === !0 && Object(t.value) === t.value && fe(o, t));
      }
    },
    beforeUnmount(e) {
      const t = e.__qripple;
      t !== void 0 && (t.abort.forEach((o) => {
        o();
      }), ot(t, "main"), delete e._qripple);
    }
  }
), Pe = {
  left: "start",
  center: "center",
  right: "end",
  between: "between",
  around: "around",
  evenly: "evenly",
  stretch: "stretch"
}, it = Object.keys(Pe), lt = {
  align: {
    type: String,
    validator: (e) => it.includes(e)
  }
};
function ct(e) {
  return m(() => {
    const t = e.align === void 0 ? e.vertical === !0 ? "stretch" : "left" : e.align;
    return `${e.vertical === !0 ? "items" : "justify"}-${Pe[t]}`;
  });
}
function dt(e) {
  return e.appContext.config.globalProperties.$router !== void 0;
}
function ft(e) {
  return e.isUnmounted === !0 || e.isDeactivated === !0;
}
function ve(e) {
  return e ? e.aliasOf ? e.aliasOf.path : e.path : "";
}
function me(e, t) {
  return (e.aliasOf || e) === (t.aliasOf || t);
}
function vt(e, t) {
  for (const o in t) {
    const n = t[o], u = e[o];
    if (typeof n == "string") {
      if (n !== u)
        return !1;
    } else if (Array.isArray(u) === !1 || u.length !== n.length || n.some((f, i) => f !== u[i]))
      return !1;
  }
  return !0;
}
function ge(e, t) {
  return Array.isArray(t) === !0 ? e.length === t.length && e.every((o, n) => o === t[n]) : e.length === 1 && e[0] === t;
}
function mt(e, t) {
  return Array.isArray(e) === !0 ? ge(e, t) : Array.isArray(t) === !0 ? ge(t, e) : e === t;
}
function gt(e, t) {
  if (Object.keys(e).length !== Object.keys(t).length)
    return !1;
  for (const o in e)
    if (mt(e[o], t[o]) === !1)
      return !1;
  return !0;
}
const ht = {
  // router-link
  to: [String, Object],
  replace: Boolean,
  exact: Boolean,
  activeClass: {
    type: String,
    default: "q-router-link--active"
  },
  exactActiveClass: {
    type: String,
    default: "q-router-link--exact-active"
  },
  // regular <a> link
  href: String,
  target: String,
  // state
  disable: Boolean
};
function pt({ fallbackTag: e, useDisableForRouterLinkProps: t = !0 } = {}) {
  const o = Q(), { props: n, proxy: u, emit: f } = o, i = dt(o), a = m(() => n.disable !== !0 && n.href !== void 0), x = t === !0 ? m(
    () => i === !0 && n.disable !== !0 && a.value !== !0 && n.to !== void 0 && n.to !== null && n.to !== ""
  ) : m(
    () => i === !0 && a.value !== !0 && n.to !== void 0 && n.to !== null && n.to !== ""
  ), h = m(() => x.value === !0 ? L(n.to) : null), d = m(() => h.value !== null), p = m(() => a.value === !0 || d.value === !0), s = m(() => n.type === "a" || p.value === !0 ? "a" : n.tag || e || "div"), r = m(() => a.value === !0 ? {
    href: n.href,
    target: n.target
  } : d.value === !0 ? {
    href: h.value.href,
    target: n.target
  } : {}), v = m(() => {
    if (d.value === !1)
      return -1;
    const { matched: g } = h.value, { length: w } = g, C = g[w - 1];
    if (C === void 0)
      return -1;
    const _ = u.$route.matched;
    if (_.length === 0)
      return -1;
    const B = _.findIndex(
      me.bind(null, C)
    );
    if (B > -1)
      return B;
    const D = ve(g[w - 2]);
    return (
      // we are dealing with nested routes
      w > 1 && ve(C) === D && _[_.length - 1].path !== D ? _.findIndex(
        me.bind(null, g[w - 2])
      ) : B
    );
  }), k = m(
    () => d.value === !0 && v.value !== -1 && vt(u.$route.params, h.value.params)
  ), c = m(
    () => k.value === !0 && v.value === u.$route.matched.length - 1 && gt(u.$route.params, h.value.params)
  ), q = m(() => d.value === !0 ? c.value === !0 ? ` ${n.exactActiveClass} ${n.activeClass}` : n.exact === !0 ? "" : k.value === !0 ? ` ${n.activeClass}` : "" : "");
  function L(g) {
    try {
      return u.$router.resolve(g);
    } catch {
    }
    return null;
  }
  function b(g, { returnRouterError: w, to: C = n.to, replace: _ = n.replace } = {}) {
    if (n.disable === !0)
      return g.preventDefault(), Promise.resolve(!1);
    if (
      // don't redirect with control keys;
      // should match RouterLink from Vue Router
      g.metaKey || g.altKey || g.ctrlKey || g.shiftKey || g.button !== void 0 && g.button !== 0 || n.target === "_blank"
    )
      return Promise.resolve(!1);
    g.preventDefault();
    const B = u.$router[_ === !0 ? "replace" : "push"](C);
    return w === !0 ? B : B.then(() => {
    }).catch(() => {
    });
  }
  function S(g) {
    if (d.value === !0) {
      const w = (C) => b(g, C);
      f("click", g, w), g.defaultPrevented !== !0 && w();
    } else
      f("click", g);
  }
  return {
    hasRouterLink: d,
    hasHrefLink: a,
    hasLink: p,
    linkTag: s,
    resolvedLink: h,
    linkIsActive: k,
    linkIsExactActive: c,
    linkClass: q,
    linkAttrs: r,
    getLink: L,
    navigateToRouterLink: b,
    navigateOnClick: S
  };
}
const he = {
  none: 0,
  xs: 4,
  sm: 8,
  md: 16,
  lg: 24,
  xl: 32
}, bt = {
  xs: 8,
  sm: 10,
  md: 14,
  lg: 20,
  xl: 24
}, yt = ["button", "submit", "reset"], kt = /[^\s]\/[^\s]/, qt = ["flat", "outline", "push", "unelevated"], Et = (e, t) => e.flat === !0 ? "flat" : e.outline === !0 ? "outline" : e.push === !0 ? "push" : e.unelevated === !0 ? "unelevated" : t, xt = {
  ...qe,
  ...ht,
  type: {
    type: String,
    default: "button"
  },
  label: [Number, String],
  icon: String,
  iconRight: String,
  ...qt.reduce(
    (e, t) => (e[t] = Boolean) && e,
    {}
  ),
  square: Boolean,
  round: Boolean,
  rounded: Boolean,
  glossy: Boolean,
  size: String,
  fab: Boolean,
  fabMini: Boolean,
  padding: String,
  color: String,
  textColor: String,
  noCaps: Boolean,
  noWrap: Boolean,
  dense: Boolean,
  tabindex: [Number, String],
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  align: {
    ...lt.align,
    default: "center"
  },
  stack: Boolean,
  stretch: Boolean,
  loading: {
    type: Boolean,
    default: null
  },
  disable: Boolean
};
function St(e) {
  const t = Ee(e, bt), o = ct(e), { hasRouterLink: n, hasLink: u, linkTag: f, linkAttrs: i, navigateOnClick: a } = pt({
    fallbackTag: "button"
  }), x = m(() => {
    const c = e.fab === !1 && e.fabMini === !1 ? t.value : {};
    return e.padding !== void 0 ? Object.assign({}, c, {
      padding: e.padding.split(/\s+/).map((q) => q in he ? he[q] + "px" : q).join(" "),
      minWidth: "0",
      minHeight: "0"
    }) : c;
  }), h = m(
    () => e.rounded === !0 || e.fab === !0 || e.fabMini === !0
  ), d = m(
    () => e.disable !== !0 && e.loading !== !0
  ), p = m(() => d.value === !0 ? e.tabindex || 0 : -1), s = m(() => Et(e, "standard")), r = m(() => {
    const c = { tabindex: p.value };
    return u.value === !0 ? Object.assign(c, i.value) : yt.includes(e.type) === !0 && (c.type = e.type), f.value === "a" ? (e.disable === !0 ? c["aria-disabled"] = "true" : c.href === void 0 && (c.role = "button"), n.value !== !0 && kt.test(e.type) === !0 && (c.type = e.type)) : e.disable === !0 && (c.disabled = "", c["aria-disabled"] = "true"), e.loading === !0 && e.percentage !== void 0 && Object.assign(c, {
      role: "progressbar",
      "aria-valuemin": 0,
      "aria-valuemax": 100,
      "aria-valuenow": e.percentage
    }), c;
  }), v = m(() => {
    let c;
    e.color !== void 0 ? e.flat === !0 || e.outline === !0 ? c = `text-${e.textColor || e.color}` : c = `bg-${e.color} text-${e.textColor || "white"}` : e.textColor && (c = `text-${e.textColor}`);
    const q = e.round === !0 ? "round" : `rectangle${h.value === !0 ? " q-btn--rounded" : e.square === !0 ? " q-btn--square" : ""}`;
    return `q-btn--${s.value} q-btn--${q}` + (c !== void 0 ? " " + c : "") + (d.value === !0 ? " q-btn--actionable q-focusable q-hoverable" : e.disable === !0 ? " disabled" : "") + (e.fab === !0 ? " q-btn--fab" : e.fabMini === !0 ? " q-btn--fab-mini" : "") + (e.noCaps === !0 ? " q-btn--no-uppercase" : "") + (e.dense === !0 ? " q-btn--dense" : "") + (e.stretch === !0 ? " no-border-radius self-stretch" : "") + (e.glossy === !0 ? " glossy" : "") + (e.square ? " q-btn--square" : "");
  }), k = m(
    () => o.value + (e.stack === !0 ? " column" : " row") + (e.noWrap === !0 ? " no-wrap text-no-wrap" : "") + (e.loading === !0 ? " q-btn__content--hidden" : "")
  );
  return {
    classes: v,
    style: x,
    innerClasses: k,
    attributes: r,
    hasLink: u,
    linkTag: f,
    navigateOnClick: a,
    isActionable: d
  };
}
const { passiveCapture: $ } = U;
let A = null, j = null, F = null;
const pe = H({
  name: "QBtn",
  props: {
    ...xt,
    percentage: Number,
    darkPercentage: Boolean,
    onTouchstart: [Function, Array]
  },
  emits: ["click", "keydown", "mousedown", "keyup"],
  setup(e, { slots: t, emit: o }) {
    const { proxy: n } = Q(), {
      classes: u,
      style: f,
      innerClasses: i,
      attributes: a,
      hasLink: x,
      linkTag: h,
      navigateOnClick: d,
      isActionable: p
    } = St(e), s = O(null), r = O(null);
    let v = null, k, c = null;
    const q = m(
      () => e.label !== void 0 && e.label !== null && e.label !== ""
    ), L = m(() => e.disable === !0 || e.ripple === !1 ? !1 : {
      keyCodes: x.value === !0 ? [13, 32] : [13],
      ...e.ripple === !0 ? {} : e.ripple
    }), b = m(() => ({ center: e.round })), S = m(() => {
      const l = Math.max(0, Math.min(100, e.percentage));
      return l > 0 ? { transition: "transform 0.6s", transform: `translateX(${l - 100}%)` } : {};
    }), g = m(() => {
      if (e.loading === !0)
        return {
          onMousedown: V,
          onTouchstart: V,
          onClick: V,
          onKeydown: V,
          onKeyup: V
        };
      if (p.value === !0) {
        const l = {
          onClick: C,
          onKeydown: _,
          onMousedown: D
        };
        if (n.$q.platform.has.touch === !0) {
          const E = e.onTouchstart !== void 0 ? "" : "Passive";
          l[`onTouchstart${E}`] = B;
        }
        return l;
      }
      return {
        // needed; especially for disabled <a> tags
        onClick: R
      };
    }), w = m(() => ({
      ref: s,
      class: "q-btn q-btn-item non-selectable no-outline " + u.value,
      style: f.value,
      ...a.value,
      ...g.value
    }));
    function C(l) {
      if (s.value !== null) {
        if (l !== void 0) {
          if (l.defaultPrevented === !0)
            return;
          const E = document.activeElement;
          if (e.type === "submit" && E !== document.body && s.value.contains(E) === !1 && E.contains(s.value) === !1) {
            s.value.focus();
            const K = () => {
              document.removeEventListener("keydown", R, !0), document.removeEventListener("keyup", K, $), s.value !== null && s.value.removeEventListener("blur", K, $);
            };
            document.addEventListener("keydown", R, !0), document.addEventListener("keyup", K, $), s.value.addEventListener("blur", K, $);
          }
        }
        d(l);
      }
    }
    function _(l) {
      s.value !== null && (o("keydown", l), Z(l, [13, 32]) === !0 && j !== s.value && (j !== null && M(), l.defaultPrevented !== !0 && (s.value.focus(), j = s.value, s.value.classList.add("q-btn--active"), document.addEventListener("keyup", P, !0), s.value.addEventListener("blur", P, $)), R(l)));
    }
    function B(l) {
      s.value !== null && (o("touchstart", l), l.defaultPrevented !== !0 && (A !== s.value && (A !== null && M(), A = s.value, v = l.target, v.addEventListener("touchcancel", P, $), v.addEventListener("touchend", P, $)), k = !0, c !== null && clearTimeout(c), c = setTimeout(() => {
        c = null, k = !1;
      }, 200)));
    }
    function D(l) {
      s.value !== null && (l.qSkipRipple = k === !0, o("mousedown", l), l.defaultPrevented !== !0 && F !== s.value && (F !== null && M(), F = s.value, s.value.classList.add("q-btn--active"), document.addEventListener("mouseup", P, $)));
    }
    function P(l) {
      if (s.value !== null && !(l !== void 0 && l.type === "blur" && document.activeElement === s.value)) {
        if (l !== void 0 && l.type === "keyup") {
          if (j === s.value && Z(l, [13, 32]) === !0) {
            const E = new MouseEvent("click", l);
            E.qKeyEvent = !0, l.defaultPrevented === !0 && nt(E), l.cancelBubble === !0 && $e(E), s.value.dispatchEvent(E), R(l), l.qKeyEvent = !0;
          }
          o("keyup", l);
        }
        M();
      }
    }
    function M(l) {
      const E = r.value;
      l !== !0 && (A === s.value || F === s.value) && E !== null && E !== document.activeElement && (E.setAttribute("tabindex", -1), E.focus()), A === s.value && (v !== null && (v.removeEventListener("touchcancel", P, $), v.removeEventListener("touchend", P, $)), A = v = null), F === s.value && (document.removeEventListener("mouseup", P, $), F = null), j === s.value && (document.removeEventListener("keyup", P, !0), s.value !== null && s.value.removeEventListener("blur", P, $), j = null), s.value !== null && s.value.classList.remove("q-btn--active");
    }
    function V(l) {
      R(l), l.qSkipRipple = !0;
    }
    return _e(() => {
      M(!0);
    }), Object.assign(n, { click: C }), () => {
      let l = [];
      e.icon !== void 0 && l.push(
        y(ce, {
          name: e.icon,
          left: e.stack === !1 && q.value === !0,
          role: "img",
          "aria-hidden": "true"
        })
      ), q.value === !0 && l.push(
        y("span", { class: "block" }, [e.label])
      ), l = z(t.default, l), e.iconRight !== void 0 && e.round === !1 && l.push(
        y(ce, {
          name: e.iconRight,
          right: e.stack === !1 && q.value === !0,
          role: "img",
          "aria-hidden": "true"
        })
      );
      const E = [
        y("span", {
          class: "q-focus-helper",
          ref: r
        })
      ];
      return e.loading === !0 && e.percentage !== void 0 && E.push(
        y("span", {
          class: "q-btn__progress absolute-full overflow-hidden" + (e.darkPercentage === !0 ? " q-btn__progress--dark" : "")
        }, [
          y("span", {
            class: "q-btn__progress-indicator fit block",
            style: S.value
          })
        ])
      ), E.push(
        y("span", {
          class: "q-btn__content text-center col items-center q-anchor--skip " + i.value
        }, l)
      ), e.loading !== null && E.push(
        y(Be, {
          name: "q-transition--fade"
        }, () => e.loading === !0 ? [
          y("span", {
            key: "loading",
            class: "absolute-full flex flex-center"
          }, t.loading !== void 0 ? t.loading() : [y(Ze)])
        ] : null)
      ), Re(
        y(
          h.value,
          w.value,
          E
        ),
        [[
          st,
          L.value,
          void 0,
          b.value
        ]]
      );
    };
  }
});
let wt = [];
function Ct(e) {
  wt.length === 0 && e();
}
const $t = "_q_fo_", Pt = H({
  name: "QForm",
  props: {
    autofocus: Boolean,
    noErrorFocus: Boolean,
    noResetFocus: Boolean,
    greedy: Boolean,
    onSubmit: Function
  },
  emits: ["reset", "validationSuccess", "validationError"],
  setup(e, { slots: t, emit: o }) {
    const n = Q(), u = O(null);
    let f = 0;
    const i = [];
    function a(r) {
      const v = typeof r == "boolean" ? r : e.noErrorFocus !== !0, k = ++f, c = (b, S) => {
        o("validation" + (b === !0 ? "Success" : "Error"), S);
      }, q = (b) => {
        const S = b.validate();
        return typeof S.then == "function" ? S.then(
          (g) => ({ valid: g, comp: b }),
          (g) => ({ valid: !1, comp: b, err: g })
        ) : Promise.resolve({ valid: S, comp: b });
      };
      return (e.greedy === !0 ? Promise.all(i.map(q)).then((b) => b.filter((S) => S.valid !== !0)) : i.reduce(
        (b, S) => b.then(() => q(S).then((g) => {
          if (g.valid === !1)
            return Promise.reject(g);
        })),
        Promise.resolve()
      ).catch((b) => [b])).then((b) => {
        if (b === void 0 || b.length === 0)
          return k === f && c(!0), !0;
        if (k === f) {
          const { comp: S, err: g } = b[0];
          if (g !== void 0 && console.error(g), c(!1, S), v === !0) {
            const w = b.find(({ comp: C }) => typeof C.focus == "function" && ft(C.$) === !1);
            w !== void 0 && w.comp.focus();
          }
        }
        return !1;
      });
    }
    function x() {
      f++, i.forEach((r) => {
        typeof r.resetValidation == "function" && r.resetValidation();
      });
    }
    function h(r) {
      r !== void 0 && R(r);
      const v = f + 1;
      a().then((k) => {
        v === f && k === !0 && (e.onSubmit !== void 0 ? o("submit", r) : r !== void 0 && r.target !== void 0 && typeof r.target.submit == "function" && r.target.submit());
      });
    }
    function d(r) {
      r !== void 0 && R(r), o("reset"), je(() => {
        x(), e.autofocus === !0 && e.noResetFocus !== !0 && p();
      });
    }
    function p() {
      Ct(() => {
        if (u.value === null)
          return;
        const r = u.value.querySelector("[autofocus][tabindex], [data-autofocus][tabindex]") || u.value.querySelector("[autofocus] [tabindex], [data-autofocus] [tabindex]") || u.value.querySelector("[autofocus], [data-autofocus]") || Array.prototype.find.call(u.value.querySelectorAll("[tabindex]"), (v) => v.tabIndex > -1);
        r != null && r.focus({ preventScroll: !0 });
      });
    }
    Le($t, {
      bindComponent(r) {
        i.push(r);
      },
      unbindComponent(r) {
        const v = i.indexOf(r);
        v > -1 && i.splice(v, 1);
      }
    });
    let s = !1;
    return Te(() => {
      s = !0;
    }), Oe(() => {
      s === !0 && e.autofocus === !0 && p();
    }), Ae(() => {
      e.autofocus === !0 && p();
    }), Object.assign(n.proxy, {
      validate: a,
      resetValidation: x,
      submit: h,
      reset: d,
      focus: p,
      getValidationComponents: () => i
    }), () => y("form", {
      class: "q-form",
      ref: u,
      onSubmit: h,
      onReset: d
    }, xe(t.default));
  }
}), _t = {
  class: /* @__PURE__ */ Y("row q-col-gutter-lg")
}, Bt = /* @__PURE__ */ ke({
  __name: "AppForm",
  props: {
    wrapperComponent: { default: () => "div" },
    layoutSlots: { default: () => 1 },
    colGutter: { default: () => "sm" },
    modelValue: {},
    modelSchema: {},
    schema: {},
    actionButtonProps: { default: () => ({}) }
  },
  emits: ["submit", "update:modelValue", "reset"],
  setup(e, { emit: t }) {
    const o = e, n = O(), { resetDefaultForm: u, validateForm: f, formData: i, fieldError: a } = Ke(
      o.modelValue
    );
    Fe(i, (r) => t("update:modelValue", r), {
      deep: !0
    });
    const x = (r) => De(i.value, r), h = (r, v) => {
      ze(
        i.value,
        v.scope,
        v != null && v.transform ? v == null ? void 0 : v.transform(r) : r
      ), a.value[v.scope] && f(o.modelSchema);
    }, d = () => {
      f(o.modelSchema), f(o.modelSchema) && t("submit", be(i.value));
    }, p = () => {
      var r;
      u(), (r = n.value) == null || r.resetValidation(), t("reset");
    }, s = (r) => ({
      bind: {
        ...r.componentProps,
        modelValue: x(r.scope),
        error: !!a.value[r.scope],
        errorMessage: a.value[r.scope] || ""
      },
      on: {
        "update:modelValue": (v) => h(v, r)
      }
    });
    return (r, v) => (T(), W(Me(Pt), {
      onSubmit: d,
      greedy: "",
      onReset: p,
      ref_key: "form",
      ref: n
    }, {
      default: I(() => [
        (T(), W(ee(r.wrapperComponent), null, {
          default: I(() => [
            te("div", _t, [
              (T(!0), N(ne, null, re(r.layoutSlots, (k) => (T(), N("div", {
                class: "col",
                key: k
              }, [
                te("div", {
                  class: Y(`row q-col-gutter-${r.colGutter}`)
                }, [
                  (T(!0), N(ne, null, re(r.schema.filter((c) => {
                    const q = c.layoutSlot || 1;
                    return q > r.layoutSlots ? k === 1 : q === k;
                  }), (c) => (T(), N("div", {
                    key: c.scope,
                    class: Y(`col-${c.cols || "auto"}`)
                  }, [
                    oe(r.$slots, c.scope, {
                      props: {
                        setterScope: h,
                        getterScope: x,
                        scope: c.scope,
                        ...s(c)
                      }
                    }, () => [
                      (T(), W(ee(c.component), X(s(c).bind, Ve(s(c).on)), null, 16))
                    ])
                  ], 2))), 128))
                ], 2)
              ]))), 128))
            ])
          ]),
          _: 3
        })),
        oe(r.$slots, "actions", {
          props: { bind: { ...r.actionButtonProps } }
        }, () => [
          ae(pe, X(r.actionButtonProps, { type: "reset" }), {
            default: I(() => [
              ue("Töm")
            ]),
            _: 1
          }, 16),
          ae(pe, X(r.actionButtonProps, {
            type: "submit",
            color: "primary"
          }), {
            default: I(() => [
              ue("Spara")
            ]),
            _: 1
          }, 16)
        ])
      ]),
      _: 3
    }, 512));
  }
}), Ot = Bt;
export {
  Ot as AppForm,
  Ke as useForm
};
